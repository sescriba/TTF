\chapter{Diseño e implementación} % Main chapter title

\label{Chapter3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

En este capítulo se expone el diseño del producto y la implementación de su arquitectura. Se describen los elementos que lo componen y la organización interna del sistema. Para ello se utilizan diagramas de bloques y de flujo de información, que permiten visualizar la estructura general y comprender cómo se articula cada componente dentro del conjunto.

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% parámetros para configurar el formato del código en los entornos lstlisting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  %extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  %frame=single,	                % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=[ANSI]C,                % the language of the code
  %otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname,                  % show the filename of files included with \lstinputlisting; also try caption instead of title
  morecomment=[s]{/*}{*/}
}


%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------
\section{Diseño del sistema}
\label{sec:diseno}
Esta sección analiza el diseño del sistema de iluminación, la conectividad entre los diferentes componentes y la interacción entre ellos. El diagrama de la figura \ref{fig:bloques} presenta, en forma de bloques, la composición del producto diferenciada en un conjunto de módulos primarios: control, comunicación con el usuario y de ingreso y egreso de señales. También permite visualizar cómo interactúa cada bloque con los demás y el flujo de información entre ellos.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, height=6cm]{./Figures/dbloques.jpg}
	\caption{Diagrama en bloques del sistema.}
	\label{fig:bloques}
\end{figure}

El bloque central del sistema es el de control. Está compuesto por el microcontrolador y se encarga del procesamiento de las señales de ingreso, de la generación de las señales de salida y de la comunicación con los diferentes sensores mediante los protocolos mencionados en la sección \ref{sec:protocolos}. También admnistra el almacenamiento, en la memoria interna, de toda la información vinculada a la configuración de hardware del producto.

Por otro lado, el bloque de comunicación con el usuario está compuesto por el módulo Bluetooth, que permite una interacción bidireccional. De este modo, el usuario puede enviar comandos específicos de configuración del hardware y, además, realizar acciones de control como encendido, ajuste de brillo o selección de color. Este bloque se conecta al microcontrolador mediante protocolo UART.

Finalmente, el bloque de señales se divide en dos submódulos: uno de ingreso de información al sistema y otro de respuesta. El ingreso está conformado por señales binarias provenientes de los sensores digitales de movimiento PIR, que detectan el desplazamiento escalón por escalón. Si bien estos sensores podrían conectarse directamente al microcontrolador mediante sus puertos específicos, se optó por utilizar extensores de puertos que se comunican con el módulo de control a través del protocolo I\textsuperscript{2}C. Una vez captados y procesados los datos, se genera la señal de egreso, necesaria por los LEDs pixel de la tira. Para ello, el módulo PWM del microcontrolador produce una serie de pulsos binarios con diferentes ciclos de trabajo y una frecuencia de 800 kHz, en cumplimiento de las especificaciones técnicas del controlador de los LEDs.

\section{Análisis del potencia}
Si bien el sistema de iluminación desarrollado en este trabajo constituye un prototipo funcional, este debe cumplir con los requisitos mínimos de tensión y corriente para operar dentro de los parámetros esperados. En primer lugar, cabe destacar que el hardware fue diseñado para iluminar cuatro escalones de un metro de ancho, utilizando de los componentes listados a continuación y ya descriptos en el capítulo \ref{Chapter2}.
\begin{itemize}
    \item Una placa de evaluación STM32 Nucleo F429ZI.
    \item Cuatro metros de tira LED pixel WS2812B.
    \item Cuatro sensores de movimiento PIR HC-SR501.
    \item Un módulo Bluetooth HC-05 sobre placa de evaluación ZS-040.
    \item Un módulo extensor de puertos PCF8574.
    \item Una protoboard, cables, transistores y resistencias.
\end{itemize}

De acuerdo a las diferentes hojas de datos todos los componentes mencionados trabajan a 5 V, por lo que puede utilizarse la misma fuente de energía para todos ellos. Sin embargo, la potencia difiere significativamente, siendo la tira LED el elemento de mayor demanda energética. Cada LED de la tira consume un máximo aproximado de 60 mA y, considerando que cada metro contiene 60 LED, la potencia requerida asciende a 3,6 A (o 18 W) por escalón.

En cuanto al microcontrolador, su hoja de datos indica un consumo de 260 µA/MHz, lo que para una operación a 180 MHz implica un consumo cercano a 240 mA. Los sensores PIR requieren 300 mW cada uno, mientras que los extensores de puertos demandan alrededor de 500 mW. El módulo Bluetooth, considerando su placa de evaluación, especifica un consumo máximo de 200 mW. 

Finalmente, el prototipo para cuatro escalones consume aproximadamente 74 W. Cabe destacar que el 97\% del consumo total recae en la iluminación de la escalera, por lo que se dispone de una única fuente de energía que responda a las necesidades expuestas anteriormente, para todos los elementos del sistema.

\section{Diseño y análisis del software}
De acuerdo a la sección \ref{sec:diseno}, el bloque de control esta compuesto por un microcontrolador que posee un software especifico para la aplicación de iluminación. En esta sección se habla de su diseño y se analizan sus componentes principales, dividiendo al mismo en diferentes módulos de implementación.

El software posee un sistema operativo en tiempo real (RTOS, del ingles {\it{Real Time Operating System}}) donde se ejecuta una tarea principal que inicializa el sistema operativo y dos tareas secundarias: una de control y procesamiento de datos y ejecución de comandos, y otra captación de datos. Dadas las características de un RTOS, las tareas se ejecutan en pseudo-simultaneidad con igual prioridad, incrementando la velocidad de ejecución del sistema.

\subsection{Tarea de control}
Esta tarea presenta una máquina de estados secuencial encargada del flujo del código de acuerdo a condiciones variables o preexistentes. En la siguiente lista se enumeran los diferentes estados:
\begin{itemize}
    \item {\it{SMPoweredDown}}: la máquina de estados se encuentra previamente apagada. Aquí se inicializan los periféricos, se encienden las fuentes de alimentación y se habilita la tarea de captación de datos.
    \item {\it{SMPoweredUp}}: la maquina de estados se encuentra previamente encendida. Aquí se le asigna una condición de encendido al controlador de luces del sistema.
    \item {\it{Run}}: es el estado central de la máquina de estados. Aquí se procesan los datos recibidos y se ejecutan los comandos de asignación de condición sobre la iluminación.
    \item {\it{Stop}}: en caso de error o de apagado forzado, aquí se apaga el controlador de luces dejando en estado de reposo.
    \item {\it{ModulePoweredDown}}: el controlador de luces se encuentra previamente apagado. Aquí se apaga la máquina de estados, incluyendo periféricos y comunicación.
\end{itemize}


\section{Análisis del software}
 
La idea de esta sección es resaltar los problemas encontrados, los criterios utilizados y la justificación de las decisiones que se hayan tomado.

Se puede agregar código o pseudocódigo dentro de un entorno lstlisting con el siguiente código:

\begin{verbatim}
\begin{lstlisting}[caption= "un epígrafe descriptivo"]
	las líneas de código irían aquí...
\end{lstlisting}
\end{verbatim}

A modo de ejemplo, se muestra el fragmento de código \ref{cod:vControl}:

\begin{lstlisting}[label=cod:vControl,caption=Pseudocódigo del lazo principal de control.]  % Start your code-block

#define MAX_SENSOR_NUMBER 3
#define MAX_ALARM_NUMBER  6
#define MAX_ACTUATOR_NUMBER 6

uint32_t sensorValue[MAX_SENSOR_NUMBER];		
FunctionalState alarmControl[MAX_ALARM_NUMBER];	//ENABLE or DISABLE
state_t alarmState[MAX_ALARM_NUMBER];						//ON or OFF
state_t actuatorState[MAX_ACTUATOR_NUMBER];			//ON or OFF

void vControl() {

	initGlobalVariables();
	
	period = 500 ms;
		
	while(1) {

		ticks = xTaskGetTickCount();
		
		updateSensors();
		
		updateAlarms();
		
		controlActuators();
		
		vTaskDelayUntil(&ticks, period);
	}
}
\end{lstlisting}



